# v1.0.1 Bug Fixes — User Testing Findings

> **Date:** 2026-02-08  
> **Source:** Manual user testing after v1.0.0 approval  
> **Priority:** Ship-blocking — all three affect core UX

---

## Bug 1: PDF Export Includes UI Chrome

### Symptom
When using Export → PDF (which calls `window.print()`), the browser print preview includes the frontmatter panel button ("Add frontmatter") and the debug panel (dev mode). Only the markdown content should print.

### Root Cause
[src/themes/print.css](../../src/themes/print.css) hides `header`, `aside`, `[role="toolbar"]`, and `.toast-container`, but it does **not** hide:

1. **`.frontmatter-panel`** — The `<FrontmatterPanel>` component renders a `<div className="frontmatter-panel ...">` that sits above the editor in the layout (inside `<main>`). The print CSS has no rule to hide it.
2. **`DebugPanel`** — The debug panel conditionally renders in dev mode (`import.meta.env.DEV`) and uses `<div className="fixed bottom-0 ...">`. The print CSS doesn't target it. In production builds it returns `null`, but during development it shows in print preview.

### Fix

Add to `@media print` in [src/themes/print.css](../../src/themes/print.css):

```css
/* Hide frontmatter panel */
.frontmatter-panel {
  display: none !important;
}

/* Hide debug panel (dev only, but belt-and-suspenders) */
.fixed.bottom-0 {
  display: none !important;
}
```

**Alternatively**, a more robust approach is to add a single wrapper class around the printable content and hide everything else:

```css
/* Hide everything outside the editor content area */
body > div > div > div > main > div:not(.editor-content-area) {
  display: none !important;
}
```

But the targeted approach (hiding `.frontmatter-panel` explicitly) is simpler and less fragile.

### Portrait vs Landscape
The user asked about portrait/landscape — this is controlled entirely by the browser's print dialog (`window.print()` opens a native dialog with orientation options). We don't need to add anything for this. It could be mentioned in a tooltip or documentation if desired.

### Effort: XS (< 15 min)

---

## Bug 2: Rendered View Cannot Scroll

### Symptom
In the rendered editor view, the mouse wheel does not scroll and no scrollbar appears. Content below the fold is only reachable via TOC navigation. This is a **critical UX bug** — the editor is unusable for any document longer than one viewport height.

### Root Cause
The CSS height chain is broken in [Editor.tsx](../../src/components/Editor/Editor.tsx#L281-L301).

Layout chain from root to scroll container:

```
App.tsx:  h-screen flex flex-col
  ├── Header
  └── flex-1 flex overflow-hidden
        ├── Sidebar
        └── main flex-1 flex flex-col overflow-hidden
              ├── FrontmatterPanel
              └── flex-1 flex overflow-hidden        ← editor area
                    └── flex-1 (or w-1/2)            ← Editor wrapper from App.tsx
                          └── Editor.tsx returns:
                              flex-1 flex overflow-hidden  ← outer
                                ├── div.w-full             ← ⚠️ BROKEN
                                │     ├── sticky TableToolbar
                                │     └── div.h-full.overflow-y-auto.p-8  ← scroll container
                                │           └── EditorContent
                                └── DebugPanel
```

**The problem:** `<div className="w-full">` (line ~283 of Editor.tsx) is a flex child of the `flex overflow-hidden` parent, so it does participate in flex layout. However, it is **not** a flex column container itself, and it has no `overflow: hidden` or constrained height. Its child `<div className="h-full overflow-y-auto">` tries to use `h-full` (100% height), but since the parent `w-full` div doesn't have an explicit height or flex constraints, the `h-full` resolves to the content's natural height rather than the container height. This means `overflow-y-auto` never activates because the container grows to fit all content.

Additionally, the `sticky top-0` TableToolbar takes up space without being part of a proper flex-column layout, further confusing the height calculation.

### Fix

Change the `w-full` wrapper in [Editor.tsx](../../src/components/Editor/Editor.tsx#L283) from:

```tsx
<div className="w-full">
```

to:

```tsx
<div className="w-full flex flex-col overflow-hidden">
```

And change the scroll container child from:

```tsx
<div className="h-full overflow-y-auto p-8">
```

to:

```tsx
<div className="flex-1 overflow-y-auto p-8">
```

**Why this works:**
- `flex flex-col overflow-hidden` makes the wrapper a flex column with constrained height (it inherits its height from the parent flex container)
- `flex-1` on the scroll container means "fill remaining space after the sticky TableToolbar"
- `overflow-y-auto` now activates because the container has a fixed height (flex-1 computes to available space)

### Effort: XS (< 15 min)

---

## Bug 3: Rich Text Export Produces Poor Output

### Symptom
"Copy as rich text" copies content that, when pasted into apps like Word/Google Docs/email, has excessive spaces, newlines, and generally looks bad. User describes it as "a worse version of the source markdown" — flat text without real formatting.

### Root Cause
In [exportHelpers.ts](../../src/utils/exportHelpers.ts#L68-L80):

```typescript
export async function copyAsRichText(editor: Editor): Promise<void> {
  const html = editor.getHTML();
  const text = editor.getText();

  const htmlBlob = new Blob([html], { type: 'text/html' });
  const textBlob = new Blob([text], { type: 'text/plain' });

  await navigator.clipboard.write([
    new ClipboardItem({
      'text/html': htmlBlob,
      'text/plain': textBlob,
    }),
  ]);
}
```

Two problems:

1. **`editor.getHTML()` outputs raw ProseMirror HTML without styling.** The HTML is structural (`<h1>`, `<p>`, `<strong>`, etc.) but has no inline styles. When pasted into rich text editors, the receiving app must interpret the HTML tags. Some apps handle this well, but many (especially email clients) produce poor results because:
   - There's no CSS — formatting relies entirely on the app's default HTML rendering
   - ProseMirror wraps content in `<p>` tags with no margin styles, so paragraphs run together
   - TipTap outputs task lists as `<ul data-type="taskList">` which most apps don't understand
   - Code blocks use `<pre><code>` with no background/font styling

2. **`editor.getText()` as the `text/plain` fallback is truly flat text** — it strips ALL formatting. When an app like Word prefers the plain text representation (or when pasting into a plain text field), you get a wall of text with no structure at all. The markdown source would actually be far more readable as a plain text fallback.

### Fix

**Approach A: Wrap HTML with inline styles (Recommended)**

Create a styled HTML export that includes inline CSS for good cross-app compatibility:

```typescript
export async function copyAsRichText(editor: Editor): Promise<void> {
  const html = editor.getHTML();
  
  // Wrap with basic styling for cross-app paste compatibility
  const styledHtml = `<div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; color: #1a1a1a;">${html}</div>`;
  
  // Use markdown as plain text fallback (more readable than getText())
  const markdown = (editor.storage as any).markdown?.getMarkdown?.() ?? editor.getText();

  const htmlBlob = new Blob([styledHtml], { type: 'text/html' });
  const textBlob = new Blob([markdown], { type: 'text/plain' });

  await navigator.clipboard.write([
    new ClipboardItem({
      'text/html': htmlBlob,
      'text/plain': textBlob,
    }),
  ]);
}
```

**Approach B: Full styled HTML with CSS (Better quality, more code)**

Process the HTML to add inline styles to key elements:

```typescript
function addInlineStyles(html: string): string {
  return html
    .replace(/<h1/g, '<h1 style="font-size: 2em; font-weight: 700; margin: 1em 0 0.5em; border-bottom: 1px solid #e5e7eb; padding-bottom: 0.3em;"')
    .replace(/<h2/g, '<h2 style="font-size: 1.5em; font-weight: 600; margin: 1em 0 0.5em; border-bottom: 1px solid #e5e7eb; padding-bottom: 0.3em;"')
    .replace(/<h3/g, '<h3 style="font-size: 1.25em; font-weight: 600; margin: 1em 0 0.5em;"')
    .replace(/<p>/g, '<p style="margin: 0.8em 0;">')
    .replace(/<blockquote/g, '<blockquote style="border-left: 4px solid #3b82f6; padding-left: 1em; margin: 1em 0; color: #6b7280; font-style: italic;"')
    .replace(/<code>/g, '<code style="background: #f3f4f6; padding: 0.2em 0.4em; border-radius: 0.25em; font-family: monospace; font-size: 0.9em;">')
    .replace(/<pre>/g, '<pre style="background: #f3f4f6; padding: 1em; border-radius: 0.5em; overflow-x: auto; font-family: monospace;">')
    .replace(/<table/g, '<table style="border-collapse: collapse; width: 100%; margin: 1em 0;"')
    .replace(/<th/g, '<th style="border: 1px solid #e5e7eb; padding: 0.5em 0.75em; background: #f9fafb; font-weight: 600;"')
    .replace(/<td/g, '<td style="border: 1px solid #e5e7eb; padding: 0.5em 0.75em;"')
    .replace(/<hr/g, '<hr style="border: none; border-top: 1px solid #e5e7eb; margin: 2em 0;"');
}
```

### Recommendation

**Approach B** — the inline styles approach produces significantly better results across Word, Google Docs, Outlook, Gmail, and other rich text contexts. The regex replacements are simple and cover the main elements. Combined with using markdown as the `text/plain` fallback, this addresses both complaints.

**Important:** Replace `editor.getText()` with `editor.storage.markdown.getMarkdown()` for the plain text fallback regardless of which approach is chosen. Markdown is *far* more readable than stripped plain text.

### Effort: S (30-60 min for Approach B + testing)

---

## Summary

| # | Bug | Severity | Root Cause | Fix Effort |
|---|-----|----------|------------|------------|
| 1 | PDF includes UI chrome | Medium | Print CSS missing selectors for `.frontmatter-panel` | XS |
| 2 | Editor doesn't scroll | **Critical** | Broken CSS height chain — `w-full` parent not flex column | XS |
| 3 | Rich text export is poor | Medium | No inline styles in HTML, `getText()` strips all formatting | S |

### Recommended Fix Order
1. **Bug 2 first** — critical, editor is unusable without scrolling
2. **Bug 1 second** — quick CSS fix
3. **Bug 3 third** — most code but medium priority

### Total Effort: S-M (1-2 hours for all three)
